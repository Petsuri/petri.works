{
  "main": {
    "works": "Petri Miikki works",
    "works_short": "Petri works",
    "open_menu": "Open menu",
    "cv": "Curriculum Vitae",
    "technologies": "Technology expertises",
    "main_page": "Main Page",
    "path_to_awesome_developer": "Path to awesome developer",
    "chapter": {
      "one": "Chapter 1: It all starts with motivation",
      "two": "Chapter 2: Establishing your current skill level",
      "three": "Chapter 3: Art of self-reflection",
      "four": "Chapter 4: Fundamentals of object-oriented programming",
      "five": "Chapter 5: SOLID principles at the beginning of your career",
      "six": "Chapter 6: Single Responsibility Principle (SRP)",
      "seven": "Chapter 7: Single Responsibility Principle exercise"
    },
    "admin_site": "Sign in"
  },
  "cv": {
    "present": "Present",
    "coming_soon": "Petri's Curriculum Vitae is coming soon",
    "education": {
      "header": "Education",
      "school": {
        "saimaa": {
          "name": "Saimaa University of Applied Sciences",
          "location": "Lappeenranta, Finland",
          "description": "Bachelor of applied sciences"
        },
        "juncheng": {
          "name": "Beijing Juncheng Language School",
          "location": "Beijing, China",
          "description": "Intensive Chinese learning course for half a year"
        },
        "btbu": {
          "name": "Beijing Technology and Business University",
          "location": "Beijing, China",
          "description": "Studying Chinese and business as part of my studies in Saimaa University of Applied Sciences"
        }
      }
    },
    "profile": {
      "header": "Profile",
      "pitch": "Tech Lead with 7+ years of experience working with web and mobile applications. Possesses a strong motivation for continuous improvement and challenging myself to develop professionally. Mentoring and coaching coworkers to achieve their own full potential and company's goals.",
      "technical_decisions": "In technical decision making always taking in to notice current context and return on investment because there is no technical decisions, only business decisions."
    },
    "skills": {
      "header": "Skills",
      "architecture": {
        "name": "Software architecture",
        "description": "From monoliths to event-driven architectures. Making decisions which the best suite business needs."
      },
      "solid": {
        "name": "SOLID principles",
        "description": "Advocate for good design practices and how to embrace code changes as possibilities and not threats. Hold workshops about "
      },
      "ddd": {
        "name": "Domain driven design",
        "description": "When products are complex with bigger teams of maintaining them, my skills of DDD with microservice patterns will bring simplicity to design."
      },
      "design_patterns": {
        "name": "Software design patterns",
        "description": "Strong skills in software design patterns allowing me to make decisions best serving business and customer needs. Doesn't under- or overengineer."
      },
      "unit_testing": {
        "name": "Unit testing",
        "description": "Skills to take the lead of defining good practices, patterns and priciples of unit testing. Passionate about writing high quality tests which are easy maintain in future."
      },
      "coaching_mentoring": {
        "name": "Coaching and mentoring",
        "description": "Always willing to share knowledge, mentor and coach others to succeed. Successfully created practices for knowledge sharing in earlier positions."
      }
    },
    "experience": {
      "header": "Experience",
      "responsibilities": "Responsibilities",
      "achievements": "Achievements",
      "tech_lead_alma_media": {
        "description": "New challenges waiting."
      },
      "management_board": {
        "description": "Growing Visma Solutions towards unicorn as a personnel member in the management board. Being part of making wide-ranging decisions about SaaS firm’s business."
      },
      "tech_lead_visma_sign": {
        "description": "Strong focus on return on investment on what we are building and what way to best benefit business. Leading technical development of Visma Sign with daily hands-on coding.",
        "responsibilities": {
          "1": "Defining coding standards",
          "2": "Architecture of the whole system",
          "3": "Improving collaboration with all functions within Visma Sign",
          "4": "Taking ownership of system development from subcontractor to Visma Solutions Oy"
        },
        "achievements": {
          "1": "Building new team to take responsibility of the product",
          "2": "Growing business from under 1M€ to over 4M€ within 2,5 years"
        }
      },
      "mobile_developer": {
        "description": "Started mobile development in Netvisor. For first 1,5 years was the only developer working on Netvisor mobile. This made me learn to be fast decision maker and focus on what actually matters for the business.",
        "responsibilities": {
          "1": "Defining and implementing architecture for Netvisor mobile app",
          "2": "Netvisor API development for supporting mobile use cases",
          "3": "Acting as a mentor for our junior software developers in Netvisor",
          "4": "Hosted workshops about unit testing, SOLID principles and domain driven design"
        },
        "achievements": {
          "1": "Employee of the year, 2018"
        }
      },
      "software_developer": {
        "description": "Worked independently at the start. Made a lot of design decisions for features what we were implementing. After moving towards teams, worked as mentor for our team members.",
        "responsibilities": {
          "1": "Designing and making integrations with other Software systems, for example Netvisor ID, Visma Scanner and Visma Webshop",
          "2": "Worked in 'technical council' as chairman for improving Netvisor's technical base",
          "3": "Acting as mentor for new developers"
        },
        "achievements": {
          "1": "Employee of the year, 2016",
          "2": "Started monthly/biweekly knowledge sharing sessions"
        }
      }
    }
  },
  "technologies": {
    "header": "Technology expertises",
    "languages": {
      "title": "Programming languages",
      "description": "I have a strong background in object-oriented design. Even though I might not have worked with a ton of languages, I have built strong knowledge about design principles & patterns, unit testable code, how to make maintainable code etc... using few different object-oriented languages. All these skills are transferable to another language without a trouble, it is just learning new syntax and base libraries used in that language.",
      "learning": "Not a long time ago, when I started working with PHP which was new language to me, it only took about one week that I was able to work with it productively since it was also object-oriented language. I was able to use all my existing skills and only transfer them to little bit different environment. Because of this, even though if I haven't worked with some OO language, I can learn it fast.",
      "profiency": "Currently I can work with following languages:"
    },
    "infrastructures": {
      "title": "Infrastructure",
      "description": "I have always had interest for cloud computing. I have read a lot of books related to this topic and understand different aspects about cloud computing and what it is all about. I have been using with all three major provides (AWS, Azure, GCP).",
      "aws": "I have been studying AWS at home. This site is also hosted in AWS and infrastructure is automated using Terraform. So all changes to this sites infrastructure is done through Terraform.",
      "gcp": "I have been using Google Cloud Platform as part of my work. We are hosting our service using GCP with help of Google Kubernetes Engine. Kubernetes itself is wide topic and I have basic knowledge of it and how to operate it.",
      "azure": "Azure is the major provider I have been using the least. Mainly just trying out Functions as part of automating workflows.",
      "knowledge": "I have knowledge of following infrastructure related things:"
    },
    "databases": {
      "title": "Databases",
      "description": "I have mainly worked with relational databases SQL Server, MySQL and MariaDB. With petri.works I am also using NoSQL database to store data and have been studying for example graph databases (Neo4j)."
    },
    "backend": {
      "title": "Backend",
      "description": "I love to work with backend related stuff, especially with business logic and architecture. This is also area that I have the most skills with and they are not technology dependent.",
      "history": "I have been working a lot of different aspects that comes to backend with designing: REST APIs, integrations, microservices, architecture, coding principles etc..."
    },
    "frontend": {
      "title": "Frontend",
      "achievement": "My biggest achievement from frontend area is Netvisor mobile app that I have created from ground up. Choosing technologies that best suites organization, making architecture decisions, defining practices, creating pipelines. All the groundwork was done by me (except UX), before we were able to recruit more teammates.",
      "web": "Web related things, I have been working mainly with React (petri.works is also done by React). I have also been using different libraries for unit testing, integration testing and end-to-end testing."
    }
  },
  "career": {
    "header": "Path to awesome software developer",
    "mentoring": {
      "program_synopsis": "This is mentoring program to develop your skills, knowledge, attitude & motivation to excel as software developer. Program is mainly meant for junior developers, at least we start at the basics, but as we are building our skills and knowledge we are moving to topics that also are relevant for more experienced developers.",
      "what_we_will_start_with": "As I am not offering silver bullets for being awesome developer. We are going to start out path with the basics:",
      "basics": {
        "coding": "Learn basics about object oriented design and check out principles from functional programming",
        "design": "Learn about software design principles ranging from SOLID to specific design patterns",
        "unit_tests": "Learn about good practices to write unit tests that stand test of time",
        "katas": "Use katas as learning tool so these things will come out of our backbones, without greater thinking",
        "motivation_and_ambition": "At the same time we are also looking about your motivation and find ambitions for being great at something"
      },
      "what_to_learn_after_basics": "When we have basics in order, we start to take look at building our own website, hosted in AWS",
      "building_website": {
        "domain": "Buying domain",
        "infrastructure": "Automating your infrastructure using Terraform",
        "frontend": "Creating frontend using React & Typescript",
        "backend": "Adding API using serverless technologies and Typescript",
        "pipeline": "Creating pipeline for automating your site deployments"
      },
      "we_will_also_touch_following_topics": "This will give you good understanding how to build new products with quality using new technologies. These skills will also be more important in the future where microservices will play more important role. During building our new site, we will also touch following topics:",
      "following_topics": {
        "decisions": "How to make decisions smartly",
        "productivity": "Talking about what makes you productivity monster and how can you improve that",
        "responsibility": "Taking responsibility for your decisions",
        "architectures": "Different architectures from monolithic approaches to serverless",
        "test_automation": "Test automation with Robot framework; e2e and integration tests",
        "micro": "Microservices and microfrontends"
      },
      "what_this_requires": "Program will take one year and requires 5 hours per week from you. I will give also a lot of book recommendations, so if you want to develop yourself even faster; you will spend more time in a week with reading books."
    },
    "good_news": "While content is under work, please subscribe to petri.works and get notified of new articles.",
    "subscribe": {
      "email": "Email",
      "invalid_email": "Given email is invalid",
      "name": "Name",
      "invalid_name": "Name length must be between {{min}} and {{max}} characters",
      "subscribe": "Subscribe",
      "success": "Successfully subscribed to petri.works",
      "error": "Subsribing to petri.works failed"
    },
    "chapter": {
      "one": {
        "header": "Chapter 1: It all starts with motivation",
        "paragraphs": {
          "1": "People are lazy by nature. We usually go from where the fence is the lowest. This is normal behavior for humans and it is nothing to be ashamed of. But motivation, it is a rare skill that separates normal from awesomeness. Since this is program for self-development, we are going to start with reflecting what is actually motivation and why is it needed. Since without motivation, you will fail this program for sure.",
          "2": "First we will have to go all the way back to year 2012. At this time I was still an exchange student in Beijing as part of my studies. I met my current in wife in May when our studies were to end in June. When we started seeing each other, we had little bit of language barrier problem. I actually only spoke Finnish, English and really basic level of Chinese when she could only could speak Chinese.",
          "3": "Since our studies were going to end June and our Visas to expire end of July, most of the exchange students were planning on going to travel around of China. This was actually first time when I had to think in the long term what I actually want. Short term joy and experiences with friends by traveling or great uncertainty with pursuing long term happiness.",
          "4": "This was actually hard decision. Uncertainty is never comfortable feeling. I chose uncertainty and stayed in our dorm while others went to travel. I had to find a way to expand my Visa if I wanted this to work. With patience I was able to find out a solution that worked out the best: apply to a school to study only Chinese for half a year for three hours a day.",
          "5": "As half a year went by, we decided together come to Finland and get marry. At this time I had been studying my bachelor of applied sciences for three years and started to think how can I provide for our future family?",
          "6": "I realized, shit, no employee would ever pay for me with my current knowledge. I haven't actually learned anything in school that would be valuable for any employee. This was the starting point for my career. Realizing how little you actually know and what are your possibilities with your current knowledge.",
          "7": "I knew this had to change or otherwise when we get kids, their life wouldn't be as good as would hope for them. Again, I faced a situation where I had to choose: go the easy way and pass all the school courses or actually accomplish what you want from the life. At this time I still had 1,5 years of school ahead of me.",
          "8": "This might be something that you didn't expect from me but I HATED programming in school. I hated it, it was awful. Lot of things that didn't make any sense. I also failed my first programming course in school...",
          "9": "Funny thing is that I didn't have a clue what I should or could do after graduating. One thing was clear, I want to provide for my family, now and in the future. My goal was clear: after graduating get a paying job. Only this one thing matters and nothing else don't.",
          "10": "I thought a lot of different things but it should be something that I can develop myself at home. Even though I hated programming at school, I thought it didn't hurt if I read something about it just to find out could it be the thing for me. I found 'Beginning C++ Though Game Programming' -book that blew me away with content that was interesting for me and it made sense. Programming made sense, I loved it. After reading and studying this book, it was end of February 2013, but one thing was clear. I will be a programmer when I graduate.",
          "11": "Then I had to self-reflect and think I what I can do to get there. I still would have ~1,5 years of school left that hadn't taught me anything (or maybe just to be lazy). But the good thing was that I knew what I want. I proposed my teachers that I would only attend required courses that I had left and otherwise would study at home programming for 30 hours per week. I am glad that I had a great teacher that approved my plan. I also heard comments that disdained me for not attending school classes and questioning me that was I sure what I was doing. But my goal was clear and I had clear vision how to get there.",
          "12": "For the next year I studied at home 30 hours per week programming. I read a lot of books, coded what I hard learned. During this time I was also looking for thesis subject so I could graduate from school. I had to turn down at least five different subjects since I knew that they wouldn't help me achieve what I wanted, a programming job. After 6 months of searching I finally finded a thesis subject that would help be get where I wanted.",
          "13": "For next four months or so, I was studying and working for the thesis 40 - 50+ hours per week. I can tell you that it wasn't easy, there wasn't pay or anything but I was sure if I work hard, self-develop myself and actually suffer for the next four months I can get my first job as programmer. This was probably hardest or the most demanding time of my life because I wanted to SHINE, SUCCEED with my thesis to being able to land my first job.",
          "14": "But it paid off, I was able to land my first job before graduating. I have self-reflected reasons for this. It is most likely because I could show that I have studied last year 1000+ hours programming (C++, C#, frameworks, concepts etc...) and I actually understood basics concepts of object-oriented programming.",
          "15": "This was a long story but with motivation long stories are needed because motivation is something that must last test of time. What I found out is that without actual motivation you can do something, maybe one week, few weeks, maximum of one month but then you can't force youselve anymore.",
          "16": "What you need to actually develop yourself and shine is a MOTIVATION, what drives you forward. This is also something that should change with your life situations and not stay stabile. Motivation is what actually separates just average from AWESOME.",
          "17": "I can tell you that my own motivations have changed multiple time over my career and this has been my strenght. To find something that motivates me go excell myself and pursue greatness.",
          "18": "Now is time for yourself to reflect, what is your motivation? Why do you want to shine? How can you actually keep on shining? It is something that you need if you want to be AWESOME.",
          "19": "You are going to need motivation to achieve anything actually meaningful in life. Without motivation you are doomed for mediocre."
        },
        "paragraph_headers": {
          "2": "Origin story for motivation",
          "6": "What had I learned in school?",
          "10": "Always try again, even if you have failed before",
          "15": "So what is the point?",
          "19": "TL;DR"
        }
      },
      "two": {
        "header": "Chapter 2: Establishing your current skill level",
        "paragraphs": {
          "1": "To begin our journey to being awesome software developer, first thing for us is to know our current skill level. Where are we at today? What are our strenghts and what skills are we missing?",
          "2": "We are going to start this chapter with a coding exercise to create baseline. After a while, one or two months, we are going to make this exercise again and self-reflect. Have we actually learned anything, if yes what and if no, why? Where can we improve? Name of the game is always to improve and understand your current limitations.",
          "3": "Petri.works has been having problems on scaling up its development resources. You have offered your help to implement new feature for petri.works which will also be your work example since petri.works might be hiring later. You should implement this with your best effort to evaluate your current skill level. You should take object-oriented approach for solving following problem:",
          "4": "As a scrooge family guy, I want to subscribe to know when meat is coming to discount at my local supermarket, so I can save money and time without having to go check meast last expiration dates all the time.",
          "5": "As a meat lover, I want to write down meat expiration dates with current €/kg prices including how many pieces are still left at supermarket, so I can help others to find cheap meat and benefit from others doing the same.",
          "6": "As a guy who just bought discounted meat, I want to inform where I just bought meat at discount with information of how many pieces, so program can maintain status of showing how many pieces of discounted meat is still left at the store.",
          "7": "As a system admin, I want to users being able to unsubscribe from getting notifications about meat discounts, so I can avoid GDPR issues.",
          "8": "---",
          "9": "Based on these user stories, implement class(es) for handling these user stories. Implementation should not have dependencies on APIs, console applications etc... and should be usable in any context. Focus on simplicity, testability, interoperability and clearness of responsibilities.",
          "10": "PS. you don't need to use concrete database or filesystem for maintaining state, instead you can use abstraction to hide away these technical details."
        },
        "paragraph_headers": {
          "3": "The exercise",
          "4": "User Story #1",
          "5": "User Story #2",
          "6": "User Story #3",
          "7": "User Story #4"
        }
      },
      "three": {
        "header": "Chapter 3: Art of self-reflection",
        "paragraphs": {
          "1": "Funny thing about us humans is that we think we are better than we actually are. If we have to assess our skills, we usually overestimate them, alot. This is even more evident for people whose skill level is lower and don't actually understand their own limitations.",
          "2": "If we actually want to develop ourselves, we must be aware our current skill level. We shouldn't overestimate our knowledge and skills, otherwise we will take shortcuts in learning and try to take quick wins since we already know so much. Something that has quickly visible results usually don't offer stable long time growth. Being software developer is not about quick wins, yes certainly you can improve quickly for a certain point but actual wisdom and stable growth comes from understanding widely the basics and building atop of them. I have seen too many \"advanced juniors\" who might even have \"senior software developer\" or some other fancy tittle but actually are still juniors if ever change jobs.",
          "3": "This can be explained by that they have worked, usually within same product, multiple years without learning new things and guarding that new ways of doing things are prohibited. This is evident if these people have had seniority over the product because they have worked there the longest. This creates a situation where people who are most confortable with current way of doing things (even how wrong they might be) will have fancy titles but if ever changing job would become a junior again. To being awere of advanced junior concept, we must avoid it by always learning and challenging current status quo.",
          "4": "Like I mentioned in chapter one, I studied over 1000 hours programming and landed my first job even before graduating from school. I had been working probably around one year and I thought I am already really good at programming. There is not that much else for me to learn. Oh boy, how wrong was I. I had quite good understanding about known unkowns, but what I was missing was unkown unkowns.",
          "5": "Now six years later, I am still in student's seat learning new things about cloud computing, micro frontends, serverless etc... But I am also teaching what I already know. There is actually good story about military life example described in \"The Art of Scalability\" -book:",
          "6": "\"Elite military units strip a potential leader down to absolutely nothing and force him to know his limits. They deprive ther person of sleep and food and force the person to live in harsh climates, with the goal of getting the person to truly understand his strengths, weaknesses and limitations.\"",
          "7": "I have thought a lot of about this. I think I have quite good understanding of my strenghts, weaknesses and limitations. For example my strenghts are limitless willingness to learn, improve, self-reflect etc... My weaknesses are that I want too much results which will affect my personal life and family. My limitations are how much time I can spend on learning now-a-days since I have a young daughter. Now that we know why undestanding your limitations is important, we will have following exercise:",
          "8": "Write down what are your current strenghts, weaknesses and limitations regarding software developer job. Next make a self-assessment about your skills in following areas:",
          "9": "Use scale of one to five:",
          "10": "This is also a baseline for our current knowledge. We will make this same assessment again after we have been progressing in this mentoring program so we can also measure our own progress.",
          "11": "After doing self-assessment, are you as good as you thought you are?"
        },
        "paragraph_headers": {
          "4": "How about self-assessment?",
          "7": "Strenghts, weaknesses and limitations"
        },
        "paragraph_list_items": {
          "8": {
            "1": "object oriented programming",
            "2": "functional programming",
            "3": "software design patterns",
            "4": "unit testing",
            "5": "architectures",
            "6": "cloud computing",
            "7": "CI/CD pipelines",
            "8": "infrastructure as code",
            "9": "front end development",
            "10": "back end development"
          },
          "9": {
            "1": "1 = you have no knowledge",
            "2": "2 = you know basics of this",
            "3": "3 = you can work this but still from time to time require help from others",
            "4": "4 = you can effectively work with this and also help others",
            "5": "5 = you can teach this subject at seminar which has hundreds of attendees"
          }
        }
      },
      "four": {
        "header": "Chapter 4: Fundamentals of object-oriented programming",
        "paragraphs": {
          "1": "If you have ever attended object-oriented programming course, it most likely contained following topics:",
          "2": "Great. You have learned the building bricks of object-oriented programming. You know what features you can use to solve problems and also understand concepts as encapsulation. Before continuing, self-reflect for a moment: what do you think is most important in object-oriented programming?",
          "3": "One of the my favourite things about object-oriented proramming is data hiding. Hide all unnecessary things from the reader and let the reader focus on what is actually important at the moment. This also enforces more abstract code making, usually, it also more readable and maintainable. Simple example of this is:",
          "4": "Do you think this code is readable and easy to maintain? If you answered yes, you are most likely still in the beginning of your programming career and are a junior software developer. Bad thing about this implementation is that we have also mixed technical complexities with business logic. With this implementation, can you even find what our business rules are? Also, this code is hard to unit test with all of its execution paths. One downside that I have also seen with these kind of implemenations is that it leads to copy paste coding since it is the only way reuse logic.",
          "5": "If we would think about hiding unnecessary things from reader of the code and have well defined responsibilities, we could refactor code above to following:",
          "6": "This implementation would allow reader to focus what is actual responsiblity of SubscrpitionService: what are actual business requirements for subscribing. This also allows easier reusability of our code, since you can use different implementations of repositories; for example mobile impelmentation could use API when your backend implementation could use NoSQL or SQL database.",
          "7": "Separation of concerns is also followed here. We are not mixing technical and business requirements, we can focus on what matters to us at that time. It might be that we have to change persistance layer; great, we don't have to think about business rules or business logic; we don't have to think about persistance.",
          "8": "For me most important thing about object-oriented programming is information hiding. Programmers can always focus on the problem at correct abstraction level. This will bring benefits at different levels, for example: unit testability, reausability, maintainability, understandability to just name a few '-ilities'.",
          "9": "We have just touched surface here. In next chapters we will focus on SOLID principles which are really close to my heart and will bring another level of excellence to your programming skills. You can already checkout excerises regarding SOLID principles here: https://github.com/Petsuri/SolidPrinciplesWorkshop"
        },
        "paragraph_headers": {
          "3": "Information hiding",
          "8": "Beyond basic OO"
        },
        "paragraph_list_items": {
          "1": {
            "1": "Classes",
            "2": "Inheritance",
            "3": "Polymorphism (aka method overloading / overriding)",
            "4": "Abstraction",
            "5": "Encapsulation"
          }
        }
      },
      "five": {
        "header": "Chapter 5: SOLID principles at the beginning of your career",
        "paragraphs": {
          "1": "It amazes me again and again how less these principles are known in the industry. For example, Liskov Substition Principle, dates back to 1988, when I wasn't even born yet, even though I lived almost 6 months in the 80's. For me, these principles have always been the backbone in the programming or even in the architecture of software. It is good to notice that SOLID principles are not exclusive to object-oriented programming; the same principles can also be applied in functional programming.",
          "2": "These principles were brought together first time in 2000 by Robert C. Martin (who has been a great inspiration for me).",
          "3": "It is strange that these fundamentals make it possible to write maintainable, extendable, unit testable etc... code is not in the mind of every developer. When I started my career in software industry; it was all about procedural programming. Yeah, I know, it was just one company/product. But I never settled for current standard or way of doing things, I always wanted to learn more.",
          "4": "I read countless books about programming in my first two years in the industry; from really generic Code Complete to more niche Writing High-Performance .NET Code. Still two most influential books I read are probably: Clean Code & Adaptive Code (1st & 2nd editions).",
          "5": "Clean Code touched on the topic of SOLID principles but sadly didn't go further in that topic. Gladly, Adaptive Code continued where Clean Code left off. It went more deeply to every principle and taught them with more discussion and insight; trade offs.",
          "6": "Probably the most important learning for me has been that knowing about theory doesn't mean anything; how you can apply your skills is everything. I have learnt this the hard way. In the early days of my career, \"architects\" called by code \"machine from hell\" when they could only write procedural code without understanding what object-oriented programming actually meant. By no means, I made code too hard to understand and read because of unnecessary abstractions etc... But I never actually got any feedback on how to structure code other than a few hundred line functions (at the baddest +1k lines; otherwise it was hard to read and follow).",
          "7": "Where I am getting with all this is; follow your instincts, trust what you have read about industry even if there might be some who disagree and most importantly: \"if you never make mistakes, you can't never learn and improve\". The last advice has been my guideline for continuous improvement; always try new things. They might fail; that is fine but you have learnt why they failed and can make better decisions in the future.",
          "8": "If I just accepted in my work environment that I should not study or try not to apply SOLID principles at work; I would probably still be a mediocre software developer at best since there was no one to mentor or teach me. It is really important not to let people talk you down or not allow them to make you have feelings of inferiority because that is what hinders your own personal development and career.",
          "9": "Most important learning for me about SOLID principles has been that they are just a tool in your toolbox. You have to remember that not everything looks like a nail even though all you have is a hammer. It always comes down to tradeoffs in your current context. It might be that other team members are not ready for SOLID principles because of too high learning curve or just unwillingness to learn new.",
          "10": "We are going to explore all principles one by one in the following chapters with examples and exercises."
        }
      },
      "six": {
        "header": "Chapter 6: Single Responsibility Principle (SRP)",
        "paragraphs": {
          "1": "This one is probably my favourite principle from SOLID. It is simple enough that anyone can understand it but few can apply it correctly in practice. So paradoxically the Single Responsibility Principle is easiest in theory but hardest to use correctly.",
          "2": "Why? Because it is most of the time opinion based. Let me explain.",
          "3": "SRP is defined as “Class should have only one responsibility for a change”. So how do you define one responsibility to change? Well usually it is easy to say that if one of the class public methods has to change, so will others; implementation wise. This will usually create a debate or discussion within a team; so how fine grained classes are we actually going to implement?",
          "4": "Do we want to always apply this principle strictly or use it when necessary? If we use this principle blindly and always; we are at the risk of introducing unnecessary complexity to our system. If on the other hand we are not using Single Responsibility Principle enough, we are creating a much harder system to maintain and evolve.",
          "5": "One of my favourite examples of codebases that are not using SRP is that all X related logic will go to XService. For example we might have PersonService that has logic to:",
          "6": "This is not actually an uncommon pattern and it actually makes sense; easy to navigate and understand. Sadly when product starts to gain new users and new business requirements start to pour in, we will soon have classes over 1000 lines of code. If we were to follow SRP, we might have classes like:",
          "7": "It always depends on the context and how you are modeling your problem domain. It is important to remember; you will make mistakes when adopting the Single Responsibility Principle. It is normal and human. Important thing is to learn and share your learnings within your current team. It will be worth it.",
          "8": "Remember that anyone can read theory but actual professionalism comes when you can apply principle as it should, taking into notice the tradeoffs."
        },
        "paragraph_headers": {
          "4": "Here comes the tradeoffs"
        },
        "paragraph_list_items": {
          "5": {
            "1": "Register person",
            "2": "Update person contact information",
            "3": "Send welcome email",
            "4": "Update password",
            "5": "Purchase credits",
            "6": "Delete account"
          },
          "6": {
            "1": "Person registration service",
            "2": "Credits purchasing service",
            "3": "Person password management",
            "4": "Person account service"
          }
        }
      },
      "seven": {
        "header": "Chapter 7: Single Responsibility Principle exercise",
        "paragraphs": {
          "1": "After reading Chapter Six, you should have a basic understanding of what Single Responsibility Principle stands for and what it means.SOLID principle exercises will be in C# but it is enough that you know some C -style language; they are mostly about design and how to refactor existing code.",
          "2": "First, fork following repository: https://github.com/Petsuri/SolidPrinciplesWorkshop",
          "3": "Navigate to  SOLID.Principles.Workshop/SRP -folder. There is a file called Pizzeria.cs. Your task is:",
          "4": "In SRP it is really important that you discuss your reasoning with your colleagues. Learn and understand your reasoning about this principle so you can improve together and write even better code to meet your customers needs.",
          "5": "What I have found is that if you actually follow SRP in your codebase, you can write code with greater certainty and make changes faster to allow your customers to have competitive advantage."
        },
        "paragraph_list_items": {
          "3": {
            "1": "List all reasons (responsibilities) for a change that the class has",
            "2": "Refactor class so that it will follow Single Responsibility Principle",
            "3": "Share your answer and discuss it with your colleagues"
          }
        }
      }
    }
  }
}
